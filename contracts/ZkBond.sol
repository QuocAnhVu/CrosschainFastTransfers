// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

/**
 * @title ZkBond
 * @author Quoc-Anh Vu
 * @dev An implementation of zero-knowledge conditional bonds. See "./Bond.sol" for info
 * about generic conditional bonds.
 *
 * The generic version has been modified so that no one but the borrow and lender can know
 * the balance and the order. This is useful to protect the borrower. For example, if the
 * borrower would like to make a trade through a decentralized exchange, a public declaration
 * bond would make the borrower vulnerable to front-running. In contrast, a zero-knowledge bond
 * would shield the borrower's public privacy while allowing lenders to see the contents underneath.
 *
 * There is special addressing with respect to the bond account holding the principal. We need
 * an account where anybody can create a transfer proof but only a special set of addresses
 * can view its balance.
 *
 * The principal of the bond belongs to the claim. In this version, funds are credited to AZTEC
 * NoteRegistries instead of this contract. Since the claim key (orderHash) is a bytes32,
 * the claim key is a natural fit to be a private key. The funds are credited to an address calculated
 * as follows: using the claim key is a private key, do a secp256k1 elliptic curve multiplication,
 * followed by a keccak256 hash, then a 20 byte truncation. The result is a standard Ethereum
 * address that is the same as if it were generated by private key (as a claim key).
 *
 * Since the claim key is public, anyone (who can guess the balance) can 
 create a valid
 * transfer proof. This is guarded by the contract, which makes sure that only claim owners can
 * submit proofs.
 *
 * For viewing, the AZTEC protocol allows anyone with a view key to view notes. The borrower
 * has to ensure that the lender is included in the view key list.
 *
 * TODO: For simplicity, this contract only assumes 1 ERC20 coin is ever traded. All funds
 * go to the same AZTEC registry.
 * TODO: Anyone with the claim key can view funds. We need a different ZK algorithm.
 */

import "./BondClaim.sol";
import "./Secp256k1.sol";

import "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC721/IERC721.sol";
import "@aztec/protocol/contracts/ERC1724/ZkAsset.sol";

contract ZkBond {
    struct ZkPrincipal {
        uint256 value;
        address token; // ERC-20 token
    }

    address claims;
    address ace;

    mapping(bytes32 => bool) exists;
    mapping(bytes32 => bool) settled;

    constructor(address _claims, address _ace) public {
        claims = _claims;
        ace = _ace;
    }

    event Issued(bytes32 principalProofHash, bytes32 orderHash);
    event Settled(bytes32 orderHash);

    /**
     * @dev Borrowers issue debt by depositing tokens and defining claim conditions.
     *
     * @param _principalProof -
     * @param _orderHash - The Order struct (which was defined in the origin Bond.sol),
     * except hashed by the borrower beforehand using keccak256. The order information
     * must be given to the lender secretly.
     */
    function issue(ZkPrincipal memory _principalProof, bytes32 _orderHash)
        public
    {
        require(
            !exists[_orderHash],
            "An order with the same claim key (orderHash) already exists."
        );

        // 1) Deposit tokens into bond from borrower's account.
        // TODO: Interact with ACE

        // if (success) {
        //     // 2) Store the bond in storage.
        //     exists[_orderHash] = true;
        //     emit Issued(_principalProofHash, _orderHash);
        // }
    }

    /**
     * @dev Claimants settle debt by proving claim ownership and withdrawing tokens.
     *
     * Claim ownership is proven if the msg.sender == ownerOf(claimToken).
     * Since claims are implemented as NFTs, they may be traded and the claim owner may
     * not be the original lender who fulfilled the order.
     *
     * @param _orderHash - A keccack256 hash of the original order struct which is also the
     *                     tokenId of the claim NFT.
     */
    function settle(bytes32 _orderHash) public {
        require(
            !isSettled(_orderHash),
            "The bond has already been settled and the account has been withdrawn from."
        );

        // 1) Verify claimant rights.
        if (
            BondClaim(claims).isClaimed(_orderHash) &&
            msg.sender == BondClaim(claims).ownerOf(uint256(_orderHash))
        ) {
            // 2) Withdraw token to claimant.
            // TODO: Interact with ACE.
            // if (success) {
            //     // 3) Mark settlement of a bond.
            //     settled[_orderHash] = true;
            //     emit Settled(_orderHash);
            // }
        }
    }

    /**
     * @dev Returns whether the bond has already been settled and the account has
     * been withdrawn from.
     *
     * @param _orderHash - A keccack256 hash of the original order struct.
     */
    function isSettled(bytes32 _orderHash) public view returns (bool ret) {
        return settled[_orderHash];
    }
}
