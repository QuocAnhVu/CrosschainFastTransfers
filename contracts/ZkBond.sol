// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

/**
 * @title ZkBond
 * @author Quoc-Anh Vu
 * @dev An implementation of zero-knowledge conditional bonds. See "./Bond.sol" for info
 * about generic conditional bonds.
 *
 * The generic version has been modified so that no one but the borrow and lender can know
 * the balance and the order. This is useful to protect the borrower. For example, if the
 * borrower would like to make a trade through a decentralized exchange, a public declaration
 * bond would make the borrower vulnerable to front-running. In contrast, a zero-knowledge bond
 * would shield the borrower's public privacy while allowing lenders to see the contents underneath.
 *
 * There is special addressing with respect to the bond account holding the principal. We need
 * an account where anybody can create a transfer proof but only a special set of addresses
 * can view its balance.
 *
 * The principal of the bond belongs to the claim. In this version, funds are credited to AZTEC
 * NoteRegistries instead of this contract. Since the claim key (orderHash) is a bytes32,
 * the claim key is a natural fit to be a private key. The funds are credited to an address calculated
 * as follows: using the claim key is a private key, do a secp256k1 elliptic curve multiplication,
 * followed by a keccak256 hash, then a 20 byte truncation. The result is a standard Ethereum
 * address that is the same as if it were generated by private key (as a claim key).
 *
 * Since the claim key is public, anyone (who can guess the balance) can 
 create a valid
 * transfer proof. This is guarded by the contract, which makes sure that only claim owners can
 * submit proofs.
 *
 * For viewing, the AZTEC protocol allows anyone with a view key to view notes. The borrower
 * has to ensure that the lender is included in the view key list.
 *
 * TODO: For simplicity, this contract only assumes 1 ERC20 coin is ever traded. All funds
 * go to the same AZTEC registry.
 * TODO: Anyone with the claim key can view funds. We need a different ZK algorithm.
 */

import "./BondClaim.sol";
import "./Secp256k1.sol";

import "openzeppelin-solidity/contracts/token/ERC20/IERC20.sol";
import "openzeppelin-solidity/contracts/token/ERC721/IERC721.sol";
import "@aztec/protocol/contracts/interfaces/IACE.sol";

contract ZkBond {
    struct TransferProof {
        uint24 proof; // The selector for the proof.
        bytes data; // The proof itself, viewing keys, and other metadata.
    }

    BondClaim public claims;
    IACE public ace;

    mapping(bytes32 => bool) exists;
    mapping(bytes32 => bool) settled;

    constructor(address _claimsAddr, address _aceAddr) public {
        claims = BondClaim(_claimsAddr);
        ace = IACE(_aceAddr);
    }

    event Issued(bytes32 principalProofHash, bytes32 orderHash);
    event Settled(bytes32 orderHash);

    /**
     * @dev Borrowers issue debt by depositing tokens and defining claim conditions.
     *
     * @param _depositProof - A proof generated by the borrower that proves that the borrower
     * will deposit funds from their account inside AZTEC to the bond's account inside AZTEC.
     * No deposit will take place until this proof is submitted to AZTEC.
     *
     * It is the borrower's responsibility to ensure that the recipient is correct and that viewing
     * keys are set up so lenders can verify the balance. This contract cannot see the contents
     * of the deposit.
     *
     * @param _orderHash - The Order struct (which was defined in the origin Bond.sol),
     * except hashed by the borrower beforehand using keccak256. The order information
     * must be given to the lender secretly.
     */
    function issue(TransferProof memory _depositProof, bytes32 _orderHash)
        public
    {
        require(
            !exists[_orderHash],
            "An order with the same claim key (orderHash) already exists."
        );

        // 1) Deposit tokens into bond from borrower's account.
        // 1a) Checks if proof is valid. Function reverts on failure. Any return counts as a success.
        bytes memory proofOutput = ace.validateProof(
            _depositProof.proof,
            msg.sender,
            _depositProof.data
        );
        // 1b) Updates account inside AZTEC if valid.
        ace.updateNoteRegistry(_depositProof.proof, proofOutput, msg.sender);

        // 2) Store the bond in storage.
        exists[_orderHash] = true;
        bytes32 proofHash = keccak256(proofOutput);
        emit Issued(proofHash, _orderHash);
    }

    /**
     * @dev Claimants settle debt by proving claim ownership and withdrawing tokens.
     *
     * Claim ownership is proven if the msg.sender == ownerOf(claimToken).
     * Since claims are implemented as NFTs, they may be traded and the claim owner may
     * not be the original lender who fulfilled the order.
     *
     * @param _withdrawProof - A proof generated by the claimant that proves that the bond
     * account inside AZTEC will transfer funds to the claimant's account inside AZTEC.
     * No withdrawal will take place until this proof is submitted to AZTEC.
     *
     * Since the private key of the bond account is public, anyone can create this proof,
     * but only the owner of the claim will have their proof submitted. It is the responsibility
     * of the claimaint to withdraw the bond account fully, as it is sealed permanently after
     * this transaction.
     *
     * @param _orderHash - A keccack256 hash of the original order struct which is also the
     *                     tokenId of the claim NFT.
     */
    function settle(TransferProof memory _withdrawProof, bytes32 _orderHash)
        public
    {
        require(
            !isSettled(_orderHash),
            "The bond has already been settled and the account has been withdrawn from."
        );

        // 1) Verify claimant rights.
        if (
            BondClaim(claims).isClaimed(_orderHash) &&
            msg.sender == BondClaim(claims).ownerOf(uint256(_orderHash))
        ) {
            // 2) Withdraw token to claimant.
            // 2a) Sets "sender address" to be the address equivalent of using the order hash as a private key.
            address orderAddr = Secp256k1.deriveAddr(uint256(_orderHash));
            // 2b) Checks if proof is valid. Function reverts on failure. Any return counts as a success.
            bytes memory proofOutput = ace.validateProof(
                _withdrawProof.proof,
                orderAddr,
                _withdrawProof.data
            );
            // 2c) Updates account inside AZTEC if valid.
            ace.updateNoteRegistry(
                _withdrawProof.proof,
                proofOutput,
                orderAddr
            );

            // 3) Mark settlement of a bond.
            settled[_orderHash] = true;
            emit Settled(_orderHash);
        }
    }

    /**
     * @dev Returns whether the bond has already been settled and the account has
     * been withdrawn from.
     *
     * @param _orderHash - A keccack256 hash of the original order struct.
     */
    function isSettled(bytes32 _orderHash) public view returns (bool ret) {
        return settled[_orderHash];
    }
}
